# -
C语言上机代码
设计文档

课程: 程序设计
题目: 生命游戏

班级: 软件工程20级		姓名: 郭仲天		学号: 19307110250

题目概要:
题目描述:
生命游戏（Game of Life）是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。它包括一个二维矩形世界，这个世界中的每个方格居住着一个活着的或死了的细胞。一个细胞在下一个时刻生死取决于相邻八个方格中活着的或死了的细胞的数量。
如果相邻方格活着的细胞数量过多，这个细胞会因为资源匮乏而在下一个时刻死去；相反，如果周围活细胞过少，这个细胞会因太孤单而死去.
在这个世界中，对于任意细胞，规则如下：每个细胞有两种状态-存活或死亡，每个
细胞与以自身为中心的周围八格细胞产生互动.
1. 当前细胞为存活状态时，当周围低于 2个（不包含 2个）存活细胞时，该细胞变
成死亡状态。（模拟生命数量稀少）
2. 当前细胞为存活状态时，当周围有 2个或 3个存活细胞时，该细胞保持原样。
3. 当前细胞为存活状态时，当周围有 3个以上的存活细胞时，该细胞变成死亡状
态。（模拟生命数量过多）
4. 当前细胞为死亡状态时，当周围有 3个存活细胞时，该细胞变成存活状态。（模拟
繁殖)
	可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后, 可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。

	题目要求:
	本项目中，需要使用 C 编程语言，结合课堂知识、lab 内容，实现一个简单的、可以在命令行下玩的生命游戏.

程序结构设计与分析:
程序结构分析:

由项目要求可知,整个项目都是基于一个二维数组也即细胞地图展开,游戏里的各种操作和命令本质上都是对该二维数组进行更改或者遍历,因此我们可以尝试将该二维数组(细胞地图)作为全局变量进行声明,这样可以减少许多调用上的繁琐操作.
除此之外,我们可以看到每一个命令都有较为明确的模块性,也即不同操作之间的耦合度较低,因此我们可以尝试着将每一个命令都封装成一个函数,而调用对应函数的判断条件是用户输入的命令与函数调用命令相同.
另外需要注意的是,由于该项目的总代码量并不大,大约只有500行左右,因此我个人认为没有必要将函数声明以及各个函数封装成不同的C文件,将函数声明以及各个操作命令的函数体放在同一个C文件里不会造成阅读和理解上的困难.因此我将函数声明,主函数,以及其它函数的函数体放置于了同一个文件: project.c当中.
以上是在开始写代码之前,我对整个程序的一个大致的结构设想.

程序结构设计:

第一部分: 指明使用的字符格式和开发环境
	字符格式: UTF-8
	开发环境:VScode

第二部分: 使用到的C语言的库函数

	#include<stdio.h>
#include<stdbool.h>
#include<string.h>
#include<stdlib.h>
#include<windows.h>
#include<conio.h>
等

	第三部分: 使用到的宏定义

		#define HELP "\\h"
#define LOAD "\\l"
#define SAVE "\\s"
#define DESIGN "\\d"
#define GENERATE "\\g"
#define RUN "\\r"
#define EXIT” \\e”
…
等

	第四部分: 在主函数中根据用户命令调用对应的命令函数

		if(strcmp(order,HELP) == 0){
            system("cls");
            printOrder();
            continue;
        }
        //加载本地地图
        else if(strcmp(order,LOAD) == 0){
            system("cls");
            importMap();
            system("cls");
            printMap(filename);
            continue;
        }
        //打印当前地图
        else if(strcmp(order,PRINT) == 0){
        	if(strlen(filename) == 0){
        		printf("还未存有地图,请导入地图(\\l)或者自定义地图(\\d).\n"); 
			}
			else{ 
	            system("cls");
	            printMap(filename);
	            continue;
            } 
        }
    	 …
		等

	第五部分: 各个命令函数的函数体的实现

		//用户导入地图的函数
void importMap(){
    FILE *fp = NULL;
    //获取文件
    while(true){
        printf("请输入您要导入的地图名称(包括文件后缀名,空格请用下划线代替)\n举例:1.txt):\n");
        scanf("%s",filename);
        fp = fopen(filename, "r");
        if(fp == NULL){
            printf("未找到文件,请重新输入:\n");
        }
        else{
            break;
        }
    }
    //将地图数据导入地图数组
    fscanf(fp, "%d", &row);
    fscanf(fp, "%d", &col);
    for(int i = 0;i < row;i++){
		for(int j = 0;j < col;j++){
            fscanf(fp,"%d", &map[i][j]);
        }
    }
    //此处必须要关闭输出流
    fclose(fp);    
}
…
等

程序基本操作:

主要函数及其功能
返回值	函数名	参数	功能
void	printWelcome	void	打印出欢迎界面和文字
void	printOrder	void	打印出各个命令函数的命令指令
void	receiveOrder	void	接收用户输入的命令,并存储到全局变量order中
void	importMap	void	将本地的txt文件中存储的地图信息加载到map数组中
void	printMap	char* c	打印数组对应的细胞状态,并将读取文件的位置显示出来
void	designMap	void	进入用户自定义地图模式
void	saveMap	void	将当前细胞地图的信息保存为本地txt文件
int	countAliveNeighbors	int map[1000][1000],
int x,int y	计算细胞地图中每个细胞周围八个细胞存活的数量
void	updateMap	int map[1000][1000]	更新细胞的下一个世代,也即细胞进行一次演化
void	exitGame	void	用户退出整个生命游戏的函数
void	runMap	void	自动进行细胞演化的函数

如何使用程序
当打开对应的程序时,会直接出现欢迎界面以及操作提示,其中:
一共有对应10个命令操作,详解如下:

1.打印命令提示(\h)
在任何输入光标前有”$”字样的,都可以直接输入’\h’字符直接获取这10中命令操作的提示信息.

2.打印当前地图(\p)
当输入\p指令后,用户可以查看当前细胞地图的演化情况,其中黑色方块代表存活细胞,白色方块代表死亡细胞.
当用户此时还未初始化细胞地图时,输入该指令会提醒用户应先导入地图或者自定义地图

3.导入地图(\l)[与课堂演示方式有所差别]
当输入\l指令后,用户会获得输入导入地图的提示信息,如果用户输入的地图文件有误,系统会提示用户重新输入,当文件成功找到并读取时,程序会直接打印出当前地图演化情况

4.保存地图(\s)[与课堂演示方式有所差别]
当输入\s指令后,用户会获得输入要导出地图的文件名的提示信息,注意此时系统限定用户输入的文件名必须包含后缀名,且必须是txt文件,当有同名文件时,会将原文件覆盖.
当文件输出成功后,系统会给出成功提示.默认输出位置为project.c文件的同源目录

5.进入地图设计模式(\d)[与课堂演示方式有所差别]
当输入\d指令后,用户会进入自定义地图模式,其中系统首先会要求用户输入设计地图的行和列(行数和列数均不得超过1000),在行数和列数被输入后,系统会依次要求用户输入要添加细胞的行和列数据,当行和列数据被填入后,细胞图会自动更新并显示.

6.退出地图设计模式(\q)
当用户在进入地图设计模式时,只需要在系统要求输入行数据时输入\q即可退出地图设计模式,此时系统会提示用户是否使用\s指令保存当前设计好的地图
当用户不在地图设计模式时,系统会告诉用户当前不在地图设计模式,需要先进入地图设计模式

7.生成下一代生命(\g)
当细胞数组中存在数据时,可以直接输入\g指令,此时会打印出下一世代细胞地图的情况,每次输入一个\g只能让细胞演化一代

8.开始生命游戏(\r)
当用户输入\r指令后,系统会以每次停顿0.5s的速度自动生成下一代细胞地图并打印出来,在这个过程中,输入回车键会暂停细胞图的演化
暂停后,如果再次输入回车,就会继续细胞演化.如果输入\e指令,就会退出自动进行细胞演化的模式.如果输入的不是以上两种,系统会提示错误并要求用户重新输入

9.停止生命游戏(\e)
详见上一条

10.退出生命游戏(end)
用户输入end后,会退出游戏的进行,结束整个程序



设计要点:

主要算法
1.通过用户命令调用对应函数的算法
首先我选择在全局变量中定义了一个order字符串,每次用户输入指令时,就将其重新赋值,之后将其与一系列指令使用strcmp函数进行匹配,如果匹配成功,就调用对应函数,否则提示输入了错误指令

2.在自定义地图模式中输入\q指令后退出该模式的算法
由于C语言中不存在自动拆装箱的类,因此我上网查找到有atoi这个函数,于是我选择了在输入行数据的时候以字符串的形式接受用户数据,倘若用户此时输入了”\	q”,那么就直接退出该模式.
如果用户输入的不是\q而是真正的int类型的行数据,那么就用atoi函数转为int类型的数据,与列数据一起更新细胞图

3.计算每个细胞周围有几个细胞存活的算法
由于助教老师提到,需要将从左(右)边和上(下)面边界溢出的细胞在右(左)边和下(上)面重新显示,也即该地图理论上应该是无限的,于是我用了取余的方式.
假设某个细胞的坐标是x,y,数组的行和列分别是row和col,那么只需要计算以下八个位置的细胞存活情况即可.
map[(x+col-1)%col][(y+row-1)%row]
map[(x+row)%row][(y+col-1)%col]
map[(x+row+1)%row][(y+col-1)%col]
map[(x+row-1)%row][(y+col)%col]
map[(x+row+1)%row][(y+col)%col]
map[(x+row-1)%row][(y+col+1)%col]
map[(x+row)%row][(y+col+1)%col]
map[(x+row+1)%row][(y+col+1)%col]
由于数组的行和列是取余的,这样就可以保证左(右)边和上(下)面边界溢出的细胞在右(左)边和下(上)面重新计算,因此就实现了细胞地图的无限延伸

4.更新细胞下一代地图的算法
如果我们直接算出一个细胞周围存活的细胞数量后直接将其演化,那么其演化的结果也会对其后面未演化的细胞造成副作用影响.
因此我选择创建一个记录map中每个细胞周围存活细胞数量的二维数组,这样在该记录数量的数组完全记录完整后,再根据map中原细胞的状态结合该数组的数据记录一起确定该细胞下一世代的状态,这样就可以有效避免细胞演化对后面未演化细胞的副作用.

5.其他例如IO流,打印欢迎信息等等的函数,它们几乎不涉及特殊的算法,都是属于基础知识和语法的范畴,因此此处就不再赘述了

编程时问题和解决策略
1.问题:
正如前面所提到的,我在自定义地图模式中使用了atoi函数以实现\q命令退出该模式,但是由于atoi函数的返回值有以下特性:
如果atoi函数的参数中包含非数字字符,会返回0代表该参数无法转换为int类型数据,然而这与用户输入在行数据上输入0,想要将第一行的细胞激活是矛盾的,这使得例如用户输入
	行数据:fasgasgj ,列数据:10 
时,也会将自定义地图的 [0][10]位置的细胞被误激活
	解决策略:
我在判断用户输入行和列数据是否合法的位置上加入了一个判断ifEnglish的boolean类型的变量,该变量默认为false,但是当出现以下情况时我会将其改为true:
			用户输入的行数据这个字符串长度大于1且atoi函数的返回值为0
			或者atoi函数的返回值为0且该字符串的第一个字符不等于’0’
那么如果ifEnglish为true,那么系统就应该显示用户输入错误(因为有非数字字符在里面),反之则不提示错误

2.问题:
自动更新细胞图时,利用kbhit函数和getch函数可以实现利用回车控制该细胞图更新的暂停和继续,但是此时实现输入\e退出自动更新和回车继续这两个实现方向存在矛盾,因为不论是gets函数还是fgets函数,个人认为都不是很好实现这个功能
	解决策略:
我选择了利用四个字符来进行记录和比较的方式,他们都是用getch这个函数获取的.
			首先是第一个字符ch1,当它等于’\r’(回车)时,便进入到以下这个循环中
第二个字符是ch2,如果ch2不是’\r’或者’\\’时,则直接提示输入不合法,让用户重新输入
第三个字符是ch3,第四个是ch4,当ch3==’e’&&ch4==’\r’时,就跳出这个循环并退出自动更新模式,否则就提示输入不合法,让用户重新输入

3.问题:
在使用\s保存地图时,即使用户将后缀名写错甚至不写,程序依然可以生成对应的文件,缺少对文件后缀名的审核判断
	解决策略:
由于C语言没有像Java语言类似的subStirng方法,因此对于字符串的截取一般需要使用strcpy函数,个人感觉截取字符串的方式远不如Java简单,而且其文件格式十分固定为txt,因此我选择依次比较用户输入的文件名的后四位字符是否是.txt,如果是,则通过并生成对应文件,反之则提示用户输入格式不对并让其重新输入
源程序:
在附件project.c中,同时还有1.txt和2.txt和3.txt三张测试地图

总结:
生命游戏这个程序属于比较典型的面向过程的程序,可以拆分的函数特征比较明显,我们可以比较容易的将其中的各个操作命令抽象成一个又一个函数来分块实现.
由于助教老师在课上展示的一些操作(比如文件的io流,自定义地图模式等)对用户使用时的输入格式要求较高(在\l或者\s后还要加上文件名,需要固定<行 列>的写法),因此我在编写程序时尽可能减少对用户输入的限制,加强和用户的互动,利用让用户多次输入的方式减少用户输入限制,让用户的输入更加方便.
由于C语言不像Java语言等有较为丰富的类库,因此在处理字符串和数组等方面明显不如Java方便,其中一个例子便是C语言没有像Java一样方便的自动拆装箱的类,因此对数据的处理可能相对繁琐.
总而言之,该生命游戏程序可以较好的让我们体会面向过程的思维,帮助我们养成将代码解耦合和模块化的思想,同时将C语言的语法知识加以巩固和复习
